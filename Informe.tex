\hypertarget{bienvenido-a-moogle}{%
\section{\texorpdfstring{-- \emph{Bienvenido a Moogle!}
--}{-- Bienvenido a Moogle! --}}\label{bienvenido-a-moogle}}

\begin{figure}
\centering
\includegraphics{moogle.png}
\caption{``Yo habia ponido mi foto aqui :(''}
\end{figure}

\begin{quote}
1er Proyecto de Programación

MatCom

Curso 2023-24

Grupo: C-122

Estudiante: Rafael A. Sánchez Martínez
\end{quote}

Original work here: https://github.com/ARKye03/MASE-Release.git

\hypertarget{features}{%
\subsection{Features}\label{features}}

\begin{itemize}
\tightlist
\item
  Soporta búsqueda de temas varios.
\item
  Modo Oscuro y Modo Claro.
\item
  Relativamente rápido, probado con 30 documentos(\textasciitilde40mb).
\item
  Capacidad de uso de operadores de Inclusión (`\^{}'), Exclusión(`!') y
  Cercanía(`\textasciitilde{}').
\item
  Posibilidad de devolver sugerencias, una vez la consulta sea procesada
  y determinada incorrecta o inexistente en el Corpus.
\item
  Muestras de pequeñas secciones de los documentos donde se haya
  encontrado lo solicitado.
\item
  Muestra el Puntaje otorgado a cada documento dependiendo de lo
  consultado.
\end{itemize}

\hypertarget{funcionamiento}{%
\subsection{Funcionamiento}\label{funcionamiento}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{-1}
\item
  Como comenzar:

  \begin{itemize}
  \item
    Si usted se encuentra en Linux, ejecutar en la carpeta del proyecto
    desde una terminal:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{make dev}
\end{Highlighting}
\end{Shaded}
  \item
    Si usted se encuentra en Windows, ejecutar en la carpeta del
    proyecto desde una terminal:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dotnet watch run {-}{-}project MoogleServer}
\end{Highlighting}
\end{Shaded}
  \end{itemize}
\item
  Inicio:

  \begin{itemize}
  \tightlist
  \item
    En la parte superior derecha elegir modo.(Oscuro, OscuroSólido,
    ClaroSólido)
  \item
    El programa inicia en \texttt{"Program.cs"}
  \end{itemize}

  \texttt{Moogle.LetsGetStarted(@"..//Content");} Ln-5

  Esta es la función invocada presente en ``Moogle.cs'': Ln-13
  \texttt{public\ static\ void\ LetsGetStarted(string\ path)\{\ corpus\ =\ new\ Corpus(path);\ \}}

  \begin{itemize}
  \tightlist
  \item
    1.1 Aqui se le da paso al motor de busqueda, que tratará de crear el
    Diccionario ``GeneralFiler'' que contendrá todas las palabras de los
    documentos `MASE Corpus -\textgreater{} Ln4'
  \item
    1.2 Tambien se creará el diccionario casi más relevante del
    proyecto, ``Docs'', que almacenará cada documento con sus datos
    `MASE Corpus -\textgreater{} Ln5'
  \end{itemize}
\item
  Corpus:

  \begin{itemize}
  \tightlist
  \item
    2.1 Se ejecuta el constructor de esta clase:

    \begin{itemize}
    \tightlist
    \item
      2.1.1 - \texttt{GetInfo()}, esta función extraerá los archivos de
      la carpeta content y los agregará al
      \texttt{GeneralFiler}(VocabularioGeneral)
    \item
      2.1.2 - \texttt{IDF()}, esta funcion calculará el IDF de las de
      los documentos, llamando la funcion \texttt{IDF} de la linea 72 de
      esa misma clase.
    \item
      2.1.3 - \texttt{WW()} o Peso de la palabra, esta funcion la uso
      para guardar el peso de cada palabra en su documento

      \begin{itemize}
      \tightlist
      \item
        2.1.3.1 Aquí se ejecuta la funcion \texttt{Peso()},
        perteneciente a la clase \texttt{Data}(Explicada más adelante),
        pero no hace más que calcular el peso de cada palabra y darle
        valor modular al documento procesado en cuestión .
      \end{itemize}
    \end{itemize}
  \item
    2.2 En las anteriores funciones se utilizaba la función
    \texttt{BuildGeneralFiler}, la cual como su nombre indica, se
    encarga de construir en \texttt{GeneralFiler}(VocabularioGeneral),
    pero además procesar y desarrollar el diccionario ``Docs''.

    \begin{itemize}
    \tightlist
    \item
      2.2.1 Aqui creo el objeto data
      \texttt{Data\ data\ =\ new\ Data();} y el conteo que indica cada
      palabra \texttt{int\ count\ =\ 0}
    \end{itemize}

    Esta zona del código fue un descubrimiento excepcional, estoy
    orgulloso de ello, horas en la página de Microsoft(no es broma)
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{private} \DataTypeTok{void} \FunctionTok{BuildGeneralFiler}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ nombre}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ i}\OperatorTok{)\{}   
\NormalTok{    Data data }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Data}\OperatorTok{();}
    \CommentTok{// Index count of each word}
    \DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} 
    \CommentTok{// Splitting with signos de puntuacion}

    \DataTypeTok{string}\NormalTok{ txt }\OperatorTok{=}\NormalTok{ File}\OperatorTok{.}\FunctionTok{ReadAllText}\OperatorTok{(}\NormalTok{Directory}\OperatorTok{.}\FunctionTok{GetFiles}\OperatorTok{(}\NormalTok{Path}\OperatorTok{,} \StringTok{"*.txt"}\OperatorTok{)[}\NormalTok{i}\OperatorTok{]).}\FunctionTok{ToLower}\OperatorTok{();}
    \DataTypeTok{string}\OperatorTok{[]}\NormalTok{ palabras }\OperatorTok{=}\NormalTok{ txt}\OperatorTok{.}\FunctionTok{Split}\OperatorTok{(}\KeywordTok{new} \DataTypeTok{char}\OperatorTok{[]} \OperatorTok{\{} \CharTok{\textquotesingle{} \textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{},\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}.\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{};\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}?\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}!\textquotesingle{}}\OperatorTok{,}\NormalTok{ \textquotesingle{}¿\textquotesingle{}}\OperatorTok{,}\NormalTok{ \textquotesingle{}¡\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}:\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}"\textquotesingle{}} \OperatorTok{\},}\NormalTok{ StringSplitOptions}\OperatorTok{.}\FunctionTok{RemoveEmptyEntries}\OperatorTok{);}
    \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{string}\NormalTok{ word }\KeywordTok{in}\NormalTok{ palabras}\OperatorTok{)\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{word}\OperatorTok{.}\FunctionTok{Length} \OperatorTok{==} \DecValTok{1} \OperatorTok{\&\&}\NormalTok{ Char}\OperatorTok{.}\FunctionTok{IsPunctuation}\OperatorTok{(}\NormalTok{word}\OperatorTok{[}\DecValTok{0}\OperatorTok{]))} \KeywordTok{continue}\OperatorTok{;}
        \CommentTok{// aqui voy guardando cada una de las palabras en el Vocabulary del documento con sus indices}
        \KeywordTok{if} \OperatorTok{(!}\NormalTok{data}\OperatorTok{.}\FunctionTok{Vocabulary}\OperatorTok{.}\FunctionTok{ContainsKey}\OperatorTok{(}\NormalTok{word}\OperatorTok{))\{}
\NormalTok{            data}\OperatorTok{.}\FunctionTok{Vocabulary}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{word}\OperatorTok{,} \KeywordTok{new}\NormalTok{ List}\OperatorTok{\textless{}}\DataTypeTok{int}\OperatorTok{\textgreater{}());}
\NormalTok{            data}\OperatorTok{.}\FunctionTok{pesos}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{word}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
            \KeywordTok{if} \OperatorTok{(!}\NormalTok{GeneralFiler}\OperatorTok{.}\FunctionTok{ContainsKey}\OperatorTok{(}\NormalTok{word}\OperatorTok{))\{}
\NormalTok{                GeneralFiler}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{word}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
            \OperatorTok{\}}
        \OperatorTok{\}}
\NormalTok{        data}\OperatorTok{.}\FunctionTok{Vocabulary}\OperatorTok{[}\NormalTok{word}\OperatorTok{].}\FunctionTok{Add}\OperatorTok{(}\NormalTok{count}\OperatorTok{);}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{data}\OperatorTok{.}\FunctionTok{Vocabulary}\OperatorTok{[}\NormalTok{word}\OperatorTok{].}\FunctionTok{Count} \OperatorTok{\textgreater{}}\NormalTok{ data}\OperatorTok{.}\FunctionTok{MaxWordAppereance}\OperatorTok{)\{}
\NormalTok{            data}\OperatorTok{.}\FunctionTok{MaxWordAppereance} \OperatorTok{=}\NormalTok{ data}\OperatorTok{.}\FunctionTok{Vocabulary}\OperatorTok{[}\NormalTok{word}\OperatorTok{].}\FunctionTok{Count}\OperatorTok{;}
        \OperatorTok{\}}
\NormalTok{        count}\OperatorTok{++;}
    \OperatorTok{\}}
\NormalTok{    Docs}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{nombre}\OperatorTok{,}\NormalTok{ data}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  \begin{itemize}
  \tightlist
  \item
    2.3.2 Como se puede ver, aquí ocurre casi toda la ``magia'', aquí se
    usan métodos propios de los diccionarios como
    \texttt{"ContainsKey"}, \texttt{"Add"}, etc. Aqui se va a separar el
    texto de cada documento por espacios y diferentes caracteres(como se
    observa arriba), y se va a ir almacenando cada palabra resultante en
    el vocabulario con sus indices, y finalmente se va a formar el
    Diccionario docs, con los nombres de los documentos y sus datos

    \begin{itemize}
    \tightlist
    \item
      2.3.2.1 Estos datos se van recopilando a lo largo del bucle
      foreach dentro de esta funcion \texttt{BuildGeneralFiler}
    \end{itemize}
  \item
    2.4 Data, la clase que contiene los datos de cada documento donde se
    calcula el peso de cada palabra en el documento que esté analizando
    en dicho momento, además le da valor a la variable \texttt{"Module"}
    del documento, que no es mas que el módulo del vector de peso
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Peso}\OperatorTok{(}\NormalTok{Dictionary}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{,} \DataTypeTok{double}\OperatorTok{\textgreater{}}\NormalTok{ GFiler}\OperatorTok{)\{}
    \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ par }\KeywordTok{in}\NormalTok{ pesos}\OperatorTok{)\{}
\NormalTok{        pesos}\OperatorTok{[}\NormalTok{par}\OperatorTok{.}\FunctionTok{Key}\OperatorTok{]} \OperatorTok{=} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\NormalTok{Vocabulary}\OperatorTok{[}\NormalTok{par}\OperatorTok{.}\FunctionTok{Key}\OperatorTok{].}\FunctionTok{Count} \OperatorTok{/} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\NormalTok{MaxWordAppereance }\OperatorTok{*}\NormalTok{ GFiler}\OperatorTok{[}\NormalTok{par}\OperatorTok{.}\FunctionTok{Key}\OperatorTok{];}
\NormalTok{        Module }\OperatorTok{+=}\NormalTok{ Math}\OperatorTok{.}\FunctionTok{Pow}\OperatorTok{(}\NormalTok{pesos}\OperatorTok{[}\NormalTok{par}\OperatorTok{.}\FunctionTok{Key}\OperatorTok{],} \DecValTok{2}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    Module }\OperatorTok{=}\NormalTok{ Math}\OperatorTok{.}\FunctionTok{Sqrt}\OperatorTok{(}\NormalTok{Module}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  \begin{itemize}
  \tightlist
  \item
    2.4.1 Otros valores da Data

    \begin{itemize}
    \tightlist
    \item
      int MaxWordAppereance = 0; -\textgreater{} Frecuencia de la
      palabra que más aparece
    \item
      Dictionary Vocabulary -\textgreater{} Este es el vocabulario del
      documento contra los indices de las palabras de ese vocabulario
    \end{itemize}
  \end{itemize}
\item
  MASE: Consulta(Seacher) y Puntaje(Score)

  \begin{itemize}
  \tightlist
  \item
    3.1 El constructor de la clase, recibe la entrada del usuario(Query)
    desde el apartado grafico, y un Corpus(El ya creado anteriormente y
    creado al inicio del proyecto)

    \begin{itemize}
    \tightlist
    \item
      \texttt{UsrInp} es la consulta del usuario ya procesada, por el
      metodo ProcessQuery, que lo que hace no es más que separar en
      terminos la consulta
    \item
      \texttt{LetMeIn}(Lista de Inclusion), \texttt{LetMeOut}(Lista de
      Exclusion), \texttt{Closeness}(Lista de cercanía), se encargaran
      de recibir los terminos de la búsqueda según los operadores
      colocados.
    \item
      \texttt{GetInfo}, es la función casi que más caótica, aquí
      primeramente se separan los terminos segun sus operadores,
      posteriormente cada palabra de la consulta va para el diccionario
      \texttt{Frqhzy} con su cantidad de repeticiones:
    \end{itemize}
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \OperatorTok{(!}\NormalTok{Frqhzy}\OperatorTok{.}\FunctionTok{ContainsKey}\OperatorTok{(}\NormalTok{UsrInp}\OperatorTok{[}\NormalTok{i}\OperatorTok{]))\{}
\NormalTok{            Frqhzy}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{UsrInp}\OperatorTok{[}\NormalTok{i}\OperatorTok{],} \DecValTok{0}\OperatorTok{);}
        \OperatorTok{\}}
\NormalTok{        Frqhzy}\OperatorTok{[}\NormalTok{UsrInp}\OperatorTok{[}\NormalTok{i}\OperatorTok{]]} \OperatorTok{+=}\NormalTok{ count1 }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{MaxWordAppereance }\OperatorTok{\textless{}}\NormalTok{ Frqhzy}\OperatorTok{[}\NormalTok{UsrInp}\OperatorTok{[}\NormalTok{i}\OperatorTok{]])\{}
\NormalTok{            MaxWordAppereance }\OperatorTok{=}\NormalTok{ Frqhzy}\OperatorTok{[}\NormalTok{UsrInp}\OperatorTok{[}\NormalTok{i}\OperatorTok{]];}
        \OperatorTok{\}}
    \OperatorTok{\}}
\NormalTok{    UsrInp }\OperatorTok{=} \KeywordTok{new} \DataTypeTok{string}\OperatorTok{[}\NormalTok{Frqhzy}\OperatorTok{.}\FunctionTok{Count}\OperatorTok{];}
    \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ par }\KeywordTok{in}\NormalTok{ Frqhzy}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        UsrInp}\OperatorTok{[}\NormalTok{count}\OperatorTok{]} \OperatorTok{=}\NormalTok{ par}\OperatorTok{.}\FunctionTok{Key}\OperatorTok{;}
\NormalTok{        count}\OperatorTok{++;}
    \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  \begin{itemize}
  \item
    3.1

    \begin{itemize}
    \tightlist
    \item
      Luego en la linea 43, el corpus declarado en esta clase searcher,
      pasa a ser el corpus enviado a consultar
    \item
      \texttt{GSuggest}, funcion que usando la distancia de
      Levensthein(Aun no optimizada), sustituye las palabras mal
      escritas o no encontradas de la consulta, por otras posiblemente
      más adecuadas. Además incorpora el método \texttt{Suggestion()}

      \begin{itemize}
      \tightlist
      \item
        \texttt{Suggestion()}
      \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private} \KeywordTok{static} \DataTypeTok{string} \FunctionTok{Suggestion}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ word}\OperatorTok{,}\NormalTok{ Corpus corpus}\OperatorTok{)\{}
\DataTypeTok{string}\NormalTok{ suggestion }\OperatorTok{=} \StringTok{""}\OperatorTok{;}

\KeywordTok{if} \OperatorTok{(!}\NormalTok{corpus}\OperatorTok{.}\FunctionTok{GeneralFiler}\OperatorTok{.}\FunctionTok{ContainsKey}\OperatorTok{(}\NormalTok{word}\OperatorTok{))\{}
    \KeywordTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ word}\OperatorTok{.}\FunctionTok{Length} \OperatorTok{/} \DecValTok{3} \OperatorTok{+} \DecValTok{1}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)\{}
        \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ pair }\KeywordTok{in}\NormalTok{ corpus}\OperatorTok{.}\FunctionTok{GeneralFiler}\OperatorTok{)\{}
            \KeywordTok{if} \OperatorTok{(}\FunctionTok{LevenstheinDistance}\OperatorTok{(}\NormalTok{word}\OperatorTok{,}\NormalTok{ pair}\OperatorTok{.}\FunctionTok{Key}\OperatorTok{)} \OperatorTok{==}\NormalTok{ i}\OperatorTok{)\{}\NormalTok{ suggestion }\OperatorTok{=} \FunctionTok{Compare}\OperatorTok{(}\NormalTok{suggestion}\OperatorTok{,}\NormalTok{ pair}\OperatorTok{.}\FunctionTok{Key}\OperatorTok{,}\NormalTok{ word}\OperatorTok{,}\NormalTok{ corpus}\OperatorTok{);} \OperatorTok{\}}
        \OperatorTok{\}}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{suggestion }\OperatorTok{!=} \StringTok{""}\OperatorTok{)} \KeywordTok{return}\NormalTok{ suggestion}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\KeywordTok{return}\NormalTok{ suggestion}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

      Usando la \texttt{distancia\ de\ Levensthein}(No optimizada aún),
      recorre palabra por palabra, para buscar por poca diferencia, la
      palabra más semejante de la consulta, para finalmente devolverla.
      {[}Mi idea es crear al inicio un diccionario extra, o varios, que
      abarquen todo el Vocabualrio de mis Docs y ordene por tamaño todas
      las palabras, asó a la hora de sugerir una palabra solo tendría
      que calcular con palabras 1 caracter más o menos grande, o de
      igual tamaño{]}
    \item
      \texttt{Snippets\ =\ new\ string{[}corpus.Docs.Count{]}} crea el
      string Snippets con longitud igual a la cantidad de documentos,
      este string pues almacenará eso, los snippets con score != 0
    \item
      \texttt{WVal\ =\ new\ double{[}UsrInp.Length{]}} es un array de
      dobles, que tendrá los valores de los terminos de la consulta, con
      capacidad == cantidad de terminos del UsrInp(Consulta).
    \item
      \texttt{Save\_W\_Value()} usando la conocida formula de TF*IDF,
      pues calcula los valores de peso de los terminos de la consulta.
      MASE LN -\textgreater{} 57
    \item
      \texttt{Mod()} Calculará el vector de pesos de la consulta
    \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \DataTypeTok{void} \FunctionTok{Mod}\OperatorTok{()\{}
\KeywordTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ WVal}\OperatorTok{.}\FunctionTok{Length}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)\{}
\NormalTok{    Module }\OperatorTok{+=}\NormalTok{ Math}\OperatorTok{.}\FunctionTok{Pow}\OperatorTok{(}\NormalTok{WVal}\OperatorTok{[}\NormalTok{i}\OperatorTok{],} \DecValTok{2}\OperatorTok{);}
\OperatorTok{\}}
\NormalTok{Module }\OperatorTok{=}\NormalTok{ Math}\OperatorTok{.}\FunctionTok{Sqrt}\OperatorTok{(}\NormalTok{Module}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

    \begin{itemize}
    \tightlist
    \item
      \texttt{FillSuggest()} Metodo que modifica la sugerencia a
      devolver.
    \end{itemize}
  \end{itemize}
\item
  Score:

  \begin{itemize}
  \tightlist
  \item
    4.1 Clase que guardará los puntajes de cada documento, para
    finalmente ser mostrado en el partado gráfico

    \begin{itemize}
    \tightlist
    \item
      \texttt{public\ Searcher\ searcher} Se declara una consulta
    \item
      \texttt{public\ Corpus\ Corpus} Se declara un corpus
    \item
      \texttt{public\ (string,\ double){[}{]}\ tupla} Se declara este
      array que será de igual tamaño que la cantidad de documentos,
      ademas almacena sus puntajes.
    \end{itemize}
  \item
    4.2 El constructor de esta clase

    \begin{itemize}
    \tightlist
    \item
      Comienza recibiendo y tomando una consulta y un corpus
    \item
      Como había dicho, la tupla se crea, con igual longitud que la
      cantidad de documentos
    \item
      \texttt{FillScores()} función que ordena las tuplas de mayor a
      menor, luego de haber ejecutado un producto vectorial con la
      funcion VecMultiply:
    \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \DataTypeTok{double} \FunctionTok{VecMultiply}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i}\OperatorTok{)\{}
\KeywordTok{if} \OperatorTok{(!}\FunctionTok{ValidateDoc}\OperatorTok{(}\NormalTok{i}\OperatorTok{)} \OperatorTok{||}\NormalTok{ searcher}\OperatorTok{.}\FunctionTok{Module} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \KeywordTok{return} \DecValTok{0}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ suma }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j}\OperatorTok{\textless{}}\NormalTok{ searcher}\OperatorTok{.}\FunctionTok{Frqhzy}\OperatorTok{.}\FunctionTok{Count}\OperatorTok{;}\NormalTok{j}\OperatorTok{++)\{}
    \KeywordTok{if} \OperatorTok{(!}\NormalTok{Corpus}\OperatorTok{.}\FunctionTok{Docs}\OperatorTok{.}\FunctionTok{ElementAt}\OperatorTok{(}\NormalTok{i}\OperatorTok{).}\FunctionTok{Value}\OperatorTok{.}\FunctionTok{pesos}\OperatorTok{.}\FunctionTok{ContainsKey}\OperatorTok{(}\NormalTok{searcher}\OperatorTok{.}\FunctionTok{Frqhzy}\OperatorTok{.}\FunctionTok{ElementAt}\OperatorTok{(}\NormalTok{j}\OperatorTok{).}\FunctionTok{Key}\OperatorTok{))} \KeywordTok{continue}\OperatorTok{;}
\NormalTok{    suma }\OperatorTok{+=}\NormalTok{ Corpus}\OperatorTok{.}\FunctionTok{Docs}\OperatorTok{.}\FunctionTok{ElementAt}\OperatorTok{(}\NormalTok{i}\OperatorTok{).}\FunctionTok{Value}\OperatorTok{.}\FunctionTok{pesos}\OperatorTok{[}\NormalTok{searcher}\OperatorTok{.}\FunctionTok{Frqhzy}\OperatorTok{.}\FunctionTok{ElementAt}\OperatorTok{(}\NormalTok{j}\OperatorTok{).}\FunctionTok{Key}\OperatorTok{]} \OperatorTok{*}\NormalTok{ searcher}\OperatorTok{.}\FunctionTok{WVal}\OperatorTok{[}\NormalTok{j}\OperatorTok{];}
\OperatorTok{\}}
\NormalTok{suma }\OperatorTok{=}\NormalTok{ suma }\OperatorTok{/} \OperatorTok{(}\NormalTok{searcher}\OperatorTok{.}\FunctionTok{Module} \OperatorTok{*}\NormalTok{ Corpus}\OperatorTok{.}\FunctionTok{Docs}\OperatorTok{.}\FunctionTok{ElementAt}\OperatorTok{(}\NormalTok{i}\OperatorTok{).}\FunctionTok{Value}\OperatorTok{.}\FunctionTok{Module}\OperatorTok{);}
\KeywordTok{return}\NormalTok{ suma}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

    \begin{itemize}
    \tightlist
    \item
      Esta funcion de \texttt{FillScores()}, tambien da inicio a la
      función \texttt{FillSnippet(tupla)} que va rellenando los
      snippet(Ver más adelante en la sección 5), además usa un metodo
      para modifcar el score, llamada \texttt{ModScore()}, que depende
      de si alguna(s) palabra(s), perteneces a la lista de Closeness y
      por tanto cambia el score en dependencia de la cercania entre esos
      terminos. Además usa un \texttt{BubbleSort()}, el metodo de sorteo
      más sencillo, recorre los terminos a pares y los intercambia si
      estan en el lugar equivocado.
    \item
      El metodo \texttt{ModScore()} usa además la función
      \texttt{LowestDistance}, que como su nombre indica devuelve la
      menor distancia entre dos términos en un documento.
    \end{itemize}
  \item
    4.3 Además uso varias funciones extras como:

    \begin{itemize}
    \tightlist
    \item
      \texttt{Swap()} Simple funcion que cambia dos elementos de lugar
      en un array.
    \item
      \texttt{TotalWeight()} Metodo que suma y devuelve los pesos de una
      palabra en cada aparicion de esta en cada documento. Se usa en la
      funcion \texttt{Compare()}.
    \item
      \texttt{ValidateDoc()} Funcion que otorgará puntaje igual a 0 a
      aquellos documentos que contengan una palabra exluida y tambien
      otorgará 0 a cada documento que no contenga a una palabra
      incluida.
    \item
      \texttt{Compare()} metodo presente en la clase Searcher, Ln
      -\textgreater{} 199, que se encargará de devolver entre dos
      palabras, la más importante usando el método
      \texttt{TotalWeight()}.
    \end{itemize}
  \end{itemize}
\item
  Snippets:

  \begin{itemize}
  \item
    5.1 \texttt{FillSnippet()} es la función, que se encarga de llenar
    los snippets de aquellos documentos que pasaron el Score(!=0)

    \begin{itemize}
    \tightlist
    \item
      Usa el hilo ``Relevant'' sinónimo de MASIMPORTANTE, que contendrá
      la palabra con la cual se presentará el Snippet más adelante.
    \item
      Al final de la función se invoca el método \texttt{RetSnippet()}.
    \end{itemize}
  \item
    5.2 \texttt{RetSnippet()} Esta recibirá, esa palabra ``Relevant'' y
    el documento donde se encuentre y creará un snippet que contenga esa
    palabra.
  \end{itemize}
\item
  Cambios en \texttt{SearchItem} y \texttt{SearchResult}

  \begin{itemize}
  \tightlist
  \item
    6.1 \texttt{SearchItem} Score, lo cambié de float a double.
  \item
    6.2 \texttt{SearchResult}

    \begin{itemize}
    \tightlist
    \item
      No declaro un objeto \texttt{SearchItem{[}{]}}, sino una
      \texttt{List\textless{}SearchItem\textgreater{}\ items}, del mismo
      nombre.
    \item
      El constructor de esta clase ahora recibe
      \texttt{List\textless{}SearchItem\textgreater{}\ items}, y su
      sobrecarga ahora hereda una Lista igualmente.
    \item
      La variable ``Count'' devuelve \texttt{this.items.Count} en lugar
      de \texttt{this.items.Length}
    \end{itemize}
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ SearchResult}
\OperatorTok{\{}
\OperatorTok{{-}}\KeywordTok{public}\NormalTok{ List}\OperatorTok{\textless{}}\NormalTok{SearchItem}\OperatorTok{\textgreater{}}\NormalTok{ items}\OperatorTok{;{-}}

\KeywordTok{public} \FunctionTok{SearchResult}\OperatorTok{({-}{-}}\NormalTok{List}\OperatorTok{\textless{}}\NormalTok{SearchItem}\OperatorTok{\textgreater{}{-}{-}}\NormalTok{ items}\OperatorTok{,} \DataTypeTok{string}\NormalTok{ suggestion}\OperatorTok{=}\StringTok{""}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{items }\OperatorTok{==} \KeywordTok{null}\OperatorTok{)} \OperatorTok{\{}
        \KeywordTok{throw} \KeywordTok{new} \FunctionTok{ArgumentNullException}\OperatorTok{(}\StringTok{"items"}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{this}\OperatorTok{.}\FunctionTok{items} \OperatorTok{=}\NormalTok{ items}\OperatorTok{;}
    \KeywordTok{this}\OperatorTok{.}\FunctionTok{Suggestion} \OperatorTok{=}\NormalTok{ suggestion}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{public} \FunctionTok{SearchResult}\OperatorTok{()} \OperatorTok{:} \KeywordTok{this}\OperatorTok{(}\KeywordTok{new} \OperatorTok{{-}{-}}\NormalTok{List}\OperatorTok{\textless{}}\NormalTok{SearchItem}\OperatorTok{\textgreater{}(){-}{-})} \OperatorTok{\{}

\OperatorTok{\}}

\KeywordTok{public} \DataTypeTok{string}\NormalTok{ Suggestion }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \KeywordTok{private} \KeywordTok{set}\OperatorTok{;} \OperatorTok{\}}

\KeywordTok{public}\NormalTok{ IEnumerable}\OperatorTok{\textless{}}\NormalTok{SearchItem}\OperatorTok{\textgreater{}} \FunctionTok{Items}\OperatorTok{()} \OperatorTok{\{}
    \KeywordTok{return} \KeywordTok{this}\OperatorTok{.}\FunctionTok{items}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{public} \DataTypeTok{int}\NormalTok{ Count }\OperatorTok{\{} \KeywordTok{get} \OperatorTok{\{} \KeywordTok{return} \OperatorTok{{-}{-}}\KeywordTok{this}\OperatorTok{.}\FunctionTok{items}\OperatorTok{.}\FunctionTok{Count}\OperatorTok{;{-}{-}} \OperatorTok{\}} \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Retornando al inicio:

  \begin{itemize}
  \tightlist
  \item
    7.1 La clase Moogle ahora:

    \begin{itemize}
    \tightlist
    \item
      Declara un \texttt{Corpus}, el mismo que da inicio al programa, y
      el cual se usará para la búsqueda.
    \item
      Declara una \texttt{Consulta(searcher)}, la cual hará todos los
      pasos y metodos anteriormente explicados.
    \item
      Declara un \texttt{Score}, puntaje que una vez procesado, será
      mostrado en pantalla, una vez culmine la búsqueda
    \item
      Un cronómetro(No Funcional\ldots{} por ahora) que mostrará cuanto
      tardó la consulta (Google-like)
    \item
      Finalmente método ``Query'' de tipo \texttt{SearchResult}

      \begin{itemize}
      \tightlist
      \item
        Dará inicio al cronómetro
      \item
        Dará orden de inicio a Searcher
      \item
        Dará orden de inicio a Score
      \end{itemize}
    \item
      Esta función ``Query'' devolverá los ``items''(Titulo, Snippet,
      Score) y la sugerencia final.
    \end{itemize}
  \item
    7.2 En Index.razor

    \begin{itemize}
    \tightlist
    \item
      Existe una nueva variable double que tendrá el valor en segundos
      del tiempo tomado en procesar la consulta.
    \item
      A esta región le agregué el ``Score''.
    \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textless{}}\NormalTok{ul }\KeywordTok{class}\OperatorTok{=}\StringTok{"results"}\OperatorTok{\textgreater{}}
\NormalTok{@}\FunctionTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ item }\KeywordTok{in}\NormalTok{ result}\OperatorTok{.}\FunctionTok{Items}\OperatorTok{())} \OperatorTok{\{}
    \OperatorTok{\textless{}}\NormalTok{li}\OperatorTok{\textgreater{}}
        \OperatorTok{\textless{}}\NormalTok{div }\KeywordTok{class}\OperatorTok{=}\StringTok{"item"}\OperatorTok{\textgreater{}}
            \OperatorTok{\textless{}}\NormalTok{p }\KeywordTok{class}\OperatorTok{=}\StringTok{"title"}\OperatorTok{\textgreater{}}\NormalTok{@item}\OperatorTok{.}\FunctionTok{Title}\OperatorTok{\textless{}/}\NormalTok{p}\OperatorTok{\textgreater{}}
            \OperatorTok{\textless{}}\NormalTok{p}\OperatorTok{\textgreater{}{-}{-}\textgreater{}}\NormalTok{  @item}\OperatorTok{.}\FunctionTok{Snippet} \OperatorTok{..\textless{}/}\NormalTok{p}\OperatorTok{\textgreater{}}
            \OperatorTok{\textless{}}\NormalTok{p}\OperatorTok{\textgreater{}{-}{-}\textgreater{}}\NormalTok{  @item}\OperatorTok{.}\FunctionTok{Score} \OperatorTok{...\textless{}/}\NormalTok{p}\OperatorTok{\textgreater{}}
        \OperatorTok{\textless{}/}\NormalTok{div}\OperatorTok{\textgreater{}}
    \OperatorTok{\textless{}/}\NormalTok{li}\OperatorTok{\textgreater{}}
\OperatorTok{\}}
\OperatorTok{\textless{}/}\NormalTok{ul}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

    \begin{itemize}
    \tightlist
    \item
      Debajo de la sugerencia irá el tiempo tomado. (Se me ocurrió a
      ultima hora).
    \end{itemize}
  \end{itemize}
\item
  Fin. 😁😁😁
\end{enumerate}
